#!/usr/bin/env perl
use strict;
use warnings;
use autodie;
use 5.010;

use Getopt::Long;
use Pod::Usage;

use Search::Elasticsearch;
use Bio::OntologyIO;

my $opts = {
    help  => 0,
    man   => 0,
    debug => 0,
    index => 'ontology',
    type  => 'do',
    do    => '/data/doid.obo.gz',
    omim  => '/data/mim2gene_medgen.gz',
    hgnc  => '/data/hgnc_mapping.tsv.gz'
};


GetOptions ($opts,
    'do=s',
    'index=s',
    'type=s',
    'omim=s',
    'hgnc=s',
    'debug',
    'help|?',
    'man',
);

pod2usage(1) if $opts->{help};
pod2usage(-exitstatus => 0, -verbose => 2) if $opts->{man};

=head1 NAME

load_DO.pl - A script to load the Disease Ontology OBO file into Elasticsearch.

=head1 SYNOPSIS

 load_DO.pl [options]

    Options:
    --help 
    --man
    --index <index name> default: ontology
    --type  <type name> default: do
    --do <DO OBO file> default: /data/doid.obo.gz
    --omim <NCBI mim2gene_medgen file> default: /data/mim2gene_medgen.gz
    --hgnc <HGNC mapping file> default: /data/hgnc_mapping.tsv.gz

e.g.
     ./load_DO.pl
     ./load_DO.pl --do /mydo.obo.gz

=head1 OPTIONS

=over 8

=item B<do> I<DO OBO file>

The DO OBO file to use.

default: /data/doid.obo.gz

=item B<index> I<index name>

The Elasticsearch index to use.

=item B<type> I<type name>

The Elasticsearch type to use.

=item B<omim> I<NCBI mim2gene_medgen>

The NCBI mim2gene_medgen file.
ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/mim2gene_medgen

default: /data/mim2gene_medgen.gz

=item B<hgnc> I<HGNC mapping file>

A custom mapping file from the HGNC that is generated by
L<bin/fetch_hgnc.pl>.

=back

=cut

my $hgnc = load_hgnc($opts->{hgnc});
my $omim = load_mim2gene($opts->{omim});

open (my $fh, '-|', "/bin/gzip -dc $opts->{do}"); 

my $es = Search::Elasticsearch->new( nodes => 'db:9200');
$es->indices->delete( index => 'ontology') if $es->indices->exists( index=> 'ontology');

my $bulk = $es->bulk_helper(
    index => $opts->{index},
    type => $opts->{type}
);

#Setup index mappings.
$es->indices->create(
    index   => $opts->{index},
    body    => {
        mappings => {
            $opts->{type} => {
                properties => {
                    id => {
                        type => 'string',
                        index => 'not_analyzed'
                    },
                    name       => { type => 'string'  },
                    definition => { type => 'string' },
                    dbxrefs => { type=> 'string' },
                    genes => {
                        type => 'string',
                        analyzer => 'simple'
                    },
                    gene_count => { type => 'integer' },
                    synonyms => { type => 'string' },
                    suggest => {
                        type => 'completion',
                        analyzer => 'simple',
                        search_analyzer => 'simple',
                        payloads => 'false'
                    }
                }
            }
        }
    }
);



my $do_parser = Bio::OntologyIO->new(
    -format => 'obo',
    -ontology_name => 'Disease Ontology',
    -fh => $fh
);

for my $ont ($do_parser->next_ontology()) {
    say "Working on " . $ont->name();

    for my $term ($ont->get_all_terms()) {
        next if $term->is_obsolete;
        say "Working on " . $term->name;

        my @dbxrefs    = $term->get_secondary_ids();
        my @synonyms   = $term->get_synonyms();
        my $genes      = get_omim_genes({ hgnc => $hgnc, omim => $omim, dbxrefs => \@dbxrefs });
        my $gene_count = scalar @{$genes};
        my $id         = $term->identifier;

        $bulk->index({
                id => $id,
                source => {
                    id => $id,
                    name => $term->name(),
                    synonyms => \@synonyms,
                    definition => $term->definition(),
                    dbxrefs => \@dbxrefs,
                    genes => $genes,
                    gene_count => $gene_count,
                    suggest => [$id, $term->name()]
                }
            }
        );
    }
}
$bulk->flush();
close($fh);

sub load_hgnc {
    my $hgnc = shift;
    my %result;
    open (my $fh, '-|', "/bin/gzip -dc $hgnc"); 
    while (<$fh>) {
        chomp;
        my ($hgnc,$symbol,$name,$prev_sym,$synonyms,$geneid,$omim,$uniprot,$ensembl) = split /\t/;
        next unless $hgnc =~ /^HGNC:\d+$/;
        next unless $geneid && $symbol;

        if ($geneid =~ /\w+/ and $symbol =~ /\w+/) {
            $result{$geneid} = $symbol;
        }
    }
    close($fh);
    return \%result;
}

sub load_mim2gene {
    my $omim = shift;
    my %result;
    open (my $fh, '-|', "/bin/gzip -dc $omim"); 
    while (<$fh>) {
        next if /^#/;
        chomp;
        my ($id,$geneid,$type,$source,$medgencui,$comment) = split /\t/;
        #Skip OMIM records that have no genes associated.
        next unless $geneid && $id;

        if ($id =~ /\w+/ and $geneid =~ /\w+/) {
            #say "Already found Gene $geneid for OMIM $id" if exists $result{$id}{$geneid};
            $result{$id}{$geneid} = undef;
        }
    }
    close($fh);
    #This turns the hash of hashes into a hash of arrays.
    #The hash of hashes was used to remove duplicate genes.
    return { map { $_ => [keys %{$result{$_}} ] } keys %result };
}

sub load_genemap {
    my $genemap = shift;

    my %result;
    open (my $fh, '-|', "/bin/gzip -dc $omim"); 
    while (<$fh>) {
        next if /^#/;
        chomp;
        my ($id,$type,$geneid,$hgnc,$ensembl) = split /\t/;
        #Skip OMIM records that have no genes associated.
        next unless $geneid && $id;

        if ($id =~ /\w+/ and $hgnc =~ /\w+/) {
            $result{$id} //= [];
            push(@{$result{$id}},$hgnc) 
        }
    }
    close($fh);
    return \%result;
}

sub get_omim_genes {
    my ($args) = @_;
    my %genes;

    my $omim = $args->{omim};
    my $hgnc = $args->{hgnc};

    for my $dbxref (@{$args->{dbxrefs}}) {
        next unless ($dbxref =~ /^OMIM:(\d+)$/);
        $dbxref =~ s/^OMIM://g; #Strip OMIM prefix off.
        if (defined $omim->{$dbxref}) {
            #Turn Gene IDs into Symbols
            map { $genes{$_} = undef } @{$hgnc}{@{$omim->{$dbxref}}};
        }
    }
    return [keys %genes ];

}

